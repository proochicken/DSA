# Describe:     

Cho mảng A[] gồm N số và thực hiện các thao tác theo nguyên tắc dưới đây:

    • Ta chọn một mảng con sao cho phần tử ở giữa của mảng con cũng là phần tử ở giữa của mảng A[] (trong trường hợp N lẻ).

    • Đảo ngược mảng con đã chọn trong mảng A[]. Ta được phép chọn mảng con và phép đảo ngược mảng con bao nhiêu lần tùy ý.

Ví dụ với mảng A[] = {1, 6, 3, 4, 5, 2, 7} ta có câu trả lời là Yes vì: ta chọn mảng con {3, 4, 5} và đảo ngược để nhận được mảng A[]={1, 6, 5, 4, 3, 2, 7}, chọn tiếp mảng con {6, 5, 4, 3, 2} và đảo ngược ta nhận được mảng A[]={1, 2, 3, 4, 5, 6, 7}. Hãy cho biết ta có thể sắp xếp được mảng A[] bằng cách thực hiện các thao tác kể trên hay không?


Input:

    • Dòng đầu tiên đưa vào số lượng bộ test T.

    • Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất đưa vào số phần tử của mảng N; dòng tiếp theo đưa vào N số A[i] tương ứng với các phần tử của mảng A[]; các số được viết cách nhau một vài khoảng trống.

    • T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤ N ≤50; 0≤A[i]≤1000.

Output:

    • Đưa ra kết quả mỗi test theo từng dòng.
    
Ví dụ:

```text
 
Input

2
7
1 6 3 4 5 2 7
7
1 6 3 4 5 7 2
```

```text
Output

Yes
No
```

# SOLUTION:     

```C++
#include <bits/stdc++.h>
using namespace std;
int main(){
    int t; cin >> t;
    while(t--){
        int n; cin >> n;
        vector<int> v(n + 1);
        for(int i = 1; i <= n; i++){
            cin >> v[i];
        }
        if(n % 2 == 0){
            int mid_1 = n / 2, mid_2 = mid_1 + 1;
            int max_m = max(v[mid_1], v[mid_2]);
            int min_m = min(v[mid_1], v[mid_2]);
            bool check = true;
            while(mid_1 >= 1 && mid_2 <= n){
                if((v[mid_1] < min_m && v[mid_2] < min_m) || (v[mid_1] > max_m && v[mid_2] > max_m)){
                    check = false;
                    break;
                }
                int max_m = max(v[mid_1], v[mid_2]);
                int min_m = min(v[mid_1], v[mid_2]);
                mid_1--; mid_2++;
            }
            if(check == true) cout << "Yes";
            else cout << "No";
        }
        else{
            bool check = true;
            if(n == 1) check = true;
            else{
                int mid = n / 2 + 1;
                int l = mid - 1, r = mid + 1;
                int max_m = v[mid], min_m = v[mid];
                while(l >= 1 && r <= n){
                    if((v[l] > max_m && v[r] > max_m) || (v[r] < min_m && v[l] < min_m)){
                        check = false;
                        break;
                    }
                    l--; r++;
                    int max_m = max(v[l], v[r]);
                    int min_m = min(v[l], v[r]);
                }
            }
            if(check == true) cout << "Yes";
            else cout << "No";
        }
        cout << endl;
    }
}
```